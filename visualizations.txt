### Combined Visual Representation of SLL Operations

#### Initial List State
```
NULL
```

#### 1. **Insert at Start (Insert 10)**
```
+-----+----+    +-----+----+
| 10  | *----> | NULL  |
+-----+----+
 Head
```

#### 2. **Insert at Last (Insert 20)**
```
+-----+----+    +-----+----+    +-----+----+
| 10  | *----> | 20  | *----> | NULL  |
+-----+----+    +-----+----+
 Head              Temp
```

#### 3. **Insert at Last (Insert 30)**
```
+-----+----+    +-----+----+    +-----+----+    +-----+----+
| 10  | *----> | 20  | *----> | 30  | *----> | NULL  |
+-----+----+    +-----+----+    +-----+----+
 Head              Temp
```

#### 4. **Insert After (Insert 25 after 20)**
```
+-----+----+    +-----+----+    +-----+----+    +-----+----+    +-----+----+
| 10  | *----> | 20  | *----> | 25  | *----> | 30  | *----> | NULL  |
+-----+----+    +-----+----+    +-----+----+    +-----+----+
 Head              Temp
```

#### 5. **Search (Find node with value 25)**
```
+-----+----+    +-----+----+    +-----+----+    +-----+----+
| 10  | *----> | 20  | *----> | 25  | *----> | 30  | *----> | NULL  |
+-----+----+    +-----+----+    +-----+----+    +-----+----+
 Head              Temp                  Found
```

#### 6. **Delete First (Remove node 10)**
```
+-----+----+    +-----+----+    +-----+----+
| 20  | *----> | 25  | *----> | 30  | *----> | NULL  |
+-----+----+    +-----+----+    +-----+----+
 New Head         Temp
```

#### 7. **Delete Last (Remove node 30)**
```
+-----+----+    +-----+----+
| 20  | *----> | 25  | *----> | NULL  |
+-----+----+    +-----+----+
 Head              Temp
```

#### 8. **Delete Item (Remove node 25)**
```
+-----+----+    +-----+----+
| 20  | *----> | NULL  |
+-----+----+
 Head
```

### Summary of Operations

1. **Insert at Start**: The new node becomes the new head.
2. **Insert at Last**: Traverse to the end and insert the new node.
3. **Insert After**: Insert a new node after the specified node.
4. **Search**: Traverse the list to find the specified node.
5. **Delete First**: Update the head to point to the second node.
6. **Delete Last**: Traverse to the second-to-last node and set its next to `NULL`.
7. **Delete Item**: Find the node and adjust pointers to remove it.

The temporary pointer (`temp`) is used to traverse and manipulate the list, ensuring operations are performed correctly.


-----------------------------------------------------------------------------------------------------------------------------------

***Doubly Linked List Visualization***

   None <-> NodeA <-> NodeB <-> NodeC <-> NodeD <-> None
           |        |        |        |       
           V        V        V        V       
          prev     prev     prev     prev     
          = None    = NodeA  = NodeB  = NodeC 
          item     item     item     item     
          = 'A'    = 'B'    = 'C'    = 'D'    
          next     next     next     next     
          = NodeB  = NodeC  = NodeD  = None


Explanation of Each Component

    Node Structure:
        Each node in a DLL consists of three primary components:
            prev: A reference to the previous node in the list. For the first node (NodeA), this is None as there is no preceding node.
            item: The data stored in the node. This example uses characters: NodeA has item = 'A', NodeB has item = 'B', NodeC has item = 'C', and NodeD has item = 'D'.
            next: A reference to the next node in the list. For the last node (NodeD), this is None as there is no following node.

    NodeA:
        prev: None (indicating it is the first node).
        item: 'A' (the data held by this node).
        next: Reference to NodeB.

    NodeB:
        prev: Reference to NodeA.
        item: 'B'.
        next: Reference to NodeC.

    NodeC:
        prev: Reference to NodeB.
        item: 'C'.
        next: Reference to NodeD.

    NodeD:
        prev: Reference to NodeC.
        item: 'D'.
        next: None (indicating it is the last node).

Key Features of the Doubly Linked List

    Bidirectional Traversal:
        Unlike a singly linked list, a DLL allows traversal in both forward and backward directions. You can move from NodeA to NodeD using the next pointers, or you can move from NodeD to NodeA using the prev pointers.

    Insertion and Deletion:
        Insertion: You can insert a new node at the start, end, or between any two nodes. For example, inserting a new node between NodeB and NodeC involves adjusting the next pointer of NodeB and the prev pointer of NodeC to include the new node.
        Deletion: Removing a node involves updating the next pointer of the previous node and the prev pointer of the next node to bypass the node being deleted. For instance, deleting NodeB involves setting NodeA.next to NodeC and NodeC.prev to NodeA.

    Dynamic Size:
        The size of a DLL can change dynamically with insertion and deletion operations. The None at both ends of the visualization represents the start and end boundaries, which are flexible and can change as nodes are added or removed.

Practical Applications

    Navigation Systems: DLLs are useful in applications where navigation backward and forward is required, such as browsers (forward and backward page navigation) or music playlists.
    Undo/Redo Mechanisms: DLLs can effectively support undo and redo functionality by moving forward and backward in the list.
